wlms %>% filter(grepl("Uzb", C1))
wlms %>% filter(grepl("Uzb", C1)) %>% st_drop_geometry() %>% distinct(NAME_PROP)
library(ggplot2)
library(ggradar)
devtools::install_github("ricardobion/ggradar")
devtools::install_github("ricardo-bion/ggradar")
library(ggplot2)
library(ggradar)
suppressPackageStartupMessages(library(dplyr))
library(scales)
mtcars %>%
add_rownames( var = "group" ) %>%
mutate_each(funs(rescale), -group) %>%
tail(4) %>% select(1:10) -> mtcars_radar
ggradar(mtcars_radar)
mtcars %>%
add_rownames( var = "group" ) %>%
mutate_each(funs(rescale), -group) %>%
tail(4) %>% select(1:10) -> mtcars_radar
library(tidyverse)
mtcars %>%
add_rownames( var = "group" ) %>%
mutate_each(funs(rescale), -group) %>%
tail(4) %>% select(1:10) -> mtcars_radar
ggradar(mtcars_radar)
mtcars
mtcars %>%
rownames_to_column( var = "group" ) %>%
mutate_each(funs(rescale), -group) %>%
tail(4) %>% select(1:10) -> mtcars_radar
ggradar(mtcars_radar)
ggradar(mtcars_radar) +
theme_dark()
ggradar(mtcars_radar) +
theme_bw()
??ggradar
ggradar(mtcars_radar, base.size = 2) +
theme_bw()
ggradar(mtcars_radar, base.size = 1) +
theme_bw()
ggradar(mtcars_radar, base.size = 10) +
theme_bw()
ggradar
??ggradar
ggradar(mtcars_radar, base.size = 10, grid.line.width = 0.1) +
theme_bw()
ggradar(mtcars_radar, base.size = 10, grid.line.width = 1) +
theme_bw()
??ggradar
ggradar(mtcars_radar, base.size = 10, group.line.width = 1) +
theme_bw()
ggradar(mtcars_radar, base.size = 10, group.line.width = 0.1) +
theme_bw()
ggradar(mtcars_radar, base.size = 10, group.line.width = 0.5) +
theme_bw()
??ggradar
ggradar(mtcars_radar, base.size = 10, group.line.width = 0.5, group.lie.point.size = 1) +
theme_bw()
ggradar(mtcars_radar, base.size = 10, group.line.width = 0.5, group.line.point.size = 1) +
theme_bw()
ggradar(mtcars_radar, base.size = 10, group.line.width = 0.5, group.point.size = 1) +
theme_bw()
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1) +
theme_bw()
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1)
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1) +
theme_void()
??ggradar
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1,
legend.position = "bottom") +
theme_void()
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1,
legend.position = "bottom") +
theme_void() +
theme(legend.position = "bottom")
??ggradar
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1,
legend.position = "bottom", background.circle.colour = "red") +
theme_void() +
theme(legend.position = "bottom")
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1,
legend.position = "bottom", background.circle.colour = "white") +
theme_void() +
theme(legend.position = "bottom")
??ggradar
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1,
legend.position = "bottom", background.circle.colour = "white",
legend.text.size = 8) +
theme_void() +
theme(legend.position = "bottom")
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1,
legend.position = "bottom", background.circle.colour = "white",
legend.text.size = 2) +
theme_void() +
theme(legend.position = "bottom")
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1,
legend.position = "bottom", background.circle.colour = "white",
legend.text.size = 1) +
theme_void() +
theme(legend.position = "bottom")
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1,
legend.position = "bottom", background.circle.colour = "white",
legend.text.size = 0.1) +
theme_void() +
theme(legend.position = "bottom")
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1,
legend.position = "bottom", background.circle.colour = "white",
legend.text.size = 100) +
theme_void() +
theme(legend.position = "bottom")
??ggradar
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1, grid.label.size = 3,
legend.position = "bottom", background.circle.colour = "white" ) +
theme_void() +
theme(legend.position = "bottom")
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1, grid.label.size = 5,
legend.position = "bottom", background.circle.colour = "white" ) +
theme_void() +
theme(legend.position = "bottom")
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1, grid.label.size = 3,
legend.position = "bottom", background.circle.colour = "white" ) +
theme_void() +
theme(legend.position = "bottom")
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1, grid.label.size = 4,
legend.position = "bottom", background.circle.colour = "white" ) +
theme_void() +
theme(legend.position = "bottom")
??ggradar
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1, grid.label.size = 4,
values.radar = c(0, 0.5, 1),
legend.position = "bottom", background.circle.colour = "white" ) +
theme_void() +
theme(legend.position = "bottom")
ggradar(mtcars_radar, group.line.width = 0.5, group.point.size = 1, grid.label.size = 6,
values.radar = c(0, 0.5, 1),
legend.position = "bottom", background.circle.colour = "white" ) +
theme_void() +
theme(legend.position = "bottom")
ggradar(mtcars_radar, group.line.width = 0.8, group.point.size = 1, grid.label.size = 6,
values.radar = c(0, 0.5, 1),
legend.position = "bottom", background.circle.colour = "white" ) +
theme_void() +
theme(legend.position = "bottom")
ggradar(mtcars_radar, group.line.width = 0.8, group.point.size = 2, grid.label.size = 6,
values.radar = c(0, 0.5, 1),
legend.position = "bottom", background.circle.colour = "white" ) +
theme_void() +
theme(legend.position = "bottom")
??ggradar
rp <- ggradar(mtcars_radar, group.line.width = 0.8, group.point.size = 2, grid.label.size = 6,
values.radar = c(0, 0.5, 1),
legend.position = "bottom", background.circle.colour = "white" ) +
theme_void() +
theme(legend.position = "bottom")
library(cowplot)
p1 <- ggplot(mtcars, aes(x = mpg, y = cyl)) +
geom_point()
p1
cowplot::plot_grid(rp, p1)
cowplot::plot_grid(p1, rp)
rp <- ggradar(mtcars_radar, group.line.width = 0.8, group.point.size = 2, grid.label.size = 6,
values.radar = c(0, 0.5, 1),
legend.position = "bottom", background.circle.colour = "white" ) +
theme_void()
p1 <- ggplot(mtcars, aes(x = mpg, y = cyl)) +
geom_point()
cowplot::plot_grid(p1, rp)
cowplot::plot_grid(p1, rp, rel_widths = c(1,2))
??ggradar
rp <- ggradar(mtcars_radar, group.line.width = 0.8, group.point.size = 2,
grid.label.size = 6, axis.label.size = 4,
values.radar = c(0, 0.5, 1),
legend.position = "bottom", background.circle.colour = "white" ) +
theme_void()
rp
rp <- ggradar(mtcars_radar, group.line.width = 0.8, group.point.size = 2,
grid.label.size = 4, axis.label.size = 4,
values.radar = c(0, 0.5, 1),
legend.position = "bottom", background.circle.colour = "white" )
rp
rp <- ggradar(mtcars_radar, group.line.width = 0.8, group.point.size = 2,
grid.label.size = 4, axis.label.size = 4, legend.label.size = 2,
values.radar = c(0, 0.5, 1),
legend.position = "bottom", background.circle.colour = "white" )
??ggradar
rp <- ggradar(mtcars_radar, group.line.width = 0.8, group.point.size = 2,
grid.label.size = 4, axis.label.size = 4, legend.text.size = 2,
values.radar = c(0, 0.5, 1),
legend.position = "bottom", background.circle.colour = "white" )
rp
rp <- ggradar(mtcars_radar, group.line.width = 0.8, group.point.size = 2,
grid.label.size = 4, axis.label.size = 4, legend.text.size = 4,
values.radar = c(0, 0.5, 1),
legend.position = "bottom", background.circle.colour = "white" )
rp
rp <- ggradar(mtcars_radar, group.line.width = 0.8, group.point.size = 2,
grid.label.size = 4, axis.label.size = 4, legend.text.size = 8,
values.radar = c(0, 0.5, 1),
legend.position = "bottom", background.circle.colour = "white" )
rp
??ggradar
rp <- ggradar(mtcars_radar, group.line.width = 0.8, group.point.size = 2,
grid.label.size = 4, axis.label.size = 4, legend.text.size = 8,
values.radar = c(0, 0.5, 1),
legend.position = "bottom", background.circle.colour = "white" ) +
guides(guide_legend)
#' @param ucdp.df A data.frame containing UCDP data with expected metadata columns.
#' @param as.text boolean: Should result be returned as text (TRUE) or printed
#' to the console (FALSE)? Default: FALSE
#'
#' @return A text summary of the metadata or message printed to console
#' @export
#'
#' @examples
#' ucdp.df <- read.csv("your_ucdp_data_file.csv")
#' getUcdpMetaData(ucdp.df, as.text = TRUE)
getUcdpMetaData <- function(ucdp.df, as.text = FALSE) {
## Define dataset names and labels
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.lbls <- setNames(c("State-based conflict", "State based conflict, battle-related deaths",
"State based conflict, dyadic", "Non-state conflict",
"One-sided violence", "Georeferenced event"), dataset.names)
## Validate required columns and extract information
required.cols <- c("dataset", "version", "download.date")
if (!all(required.cols %in% names(ucdp.df))) {
warning("Metadata variables not found, outputting only known information.")
dataset <- version <- dataset.lbl <- "**unknown**"
download.date <- NA
} else {
dataset <- unique(ucdp.df$dataset)
dataset.lbl <- dataset.lbls[dataset]
version <- unique(ucdp.df$version)
download.date <- unique(ucdp.df$download.date)
}
## Process dates and coverage
if (dataset == "gedevents") {
ged.dates <- as.Date(unique(ucdp.df$date_start))
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
date.gaps <- all.dates[!all.dates %in% ged.dates]
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
} else {
years <- unique(ucdp.df$year)
start <- min(years)
end <- max(years)
}
## Format download date
download.date.formatted <- if(!is.na(download.date)){
format(download.date, '%d %B %Y')
} else {
"**unknown date**"
}
## Construct message text
txt <- glue::glue(
"UCDP {dataset.lbl} dataset, downloaded through the UCDP API on {download.date.formatted} using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api \n\n",
"Dataset version(s): {paste(version, collapse = ', ')} \n",
"Data coverage: {start} to {end} \n",
"For more information on the UCDP data and API, visit: https://ucdp.uu.se/apidocs/ \n",
if (dataset == "gedevents") {
date.gaps.msg <- if (!as.text && length(date.gaps) > 20) {
paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
} else {
paste(date.gaps, collapse = ", ")
}
sprintf("%s Date(s) missing from dataset:\n\n%s.", length(date.gaps), date.gaps.msg)
} else {
""
}
)
if (as.text) {
return(txt)
} else {
message(txt)
}
}
devtools::document()
install.packages("roxygen2")
install.packages("roxygen2")
#' @param ucdp.df A data.frame containing UCDP data with expected metadata columns.
#' @param as.text boolean: Should result be returned as text (TRUE) or printed
#' to the console (FALSE)? Default: FALSE
#'
#' @return A text summary of the metadata or message printed to console.
#' @export
#'
#' @examples
#' ucdp.df <- read.csv("your_ucdp_data_file.csv")
#' getUcdpMetaData(ucdp.df, as.text = TRUE)
getUcdpMetaData <- function(ucdp.df, as.text = FALSE) {
## Define dataset names and labels
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.lbls <- setNames(c("State-based conflict", "State based conflict, battle-related deaths",
"State based conflict, dyadic", "Non-state conflict",
"One-sided violence", "Georeferenced event"), dataset.names)
## Validate required columns and extract information
required.cols <- c("dataset", "version", "download.date")
if (!all(required.cols %in% names(ucdp.df))) {
warning("Metadata variables not found, outputting only known information.")
dataset <- version <- dataset.lbl <- "**unknown**"
download.date <- NA
} else {
dataset <- unique(ucdp.df$dataset)
dataset.lbl <- dataset.lbls[dataset]
version <- unique(ucdp.df$version)
download.date <- unique(ucdp.df$download.date)
}
## Process dates and coverage
if (dataset == "gedevents") {
ged.dates <- as.Date(unique(ucdp.df$date_start))
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
date.gaps <- all.dates[!all.dates %in% ged.dates]
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
} else {
years <- unique(ucdp.df$year)
start <- min(years)
end <- max(years)
}
## Format download date
download.date.formatted <- if(!is.na(download.date)){
format(download.date, '%d %B %Y')
} else {
"**unknown date**"
}
## Construct message text
txt <- glue::glue(
"UCDP {dataset.lbl} dataset, downloaded through the UCDP API on {download.date.formatted} using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api \n\n",
"Dataset version(s): {paste(version, collapse = ', ')} \n",
"Data coverage: {start} to {end} \n",
"For more information on the UCDP data and API, visit: https://ucdp.uu.se/apidocs/ \n",
if (dataset == "gedevents") {
date.gaps.msg <- if (!as.text && length(date.gaps) > 20) {
paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
} else {
paste(date.gaps, collapse = ", ")
}
sprintf("%s Date(s) missing from dataset:\n\n%s.", length(date.gaps), date.gaps.msg)
} else {
""
}
)
if (as.text) {
return(txt)
} else {
message(txt)
}
}
library(ucdp.api)
ged.df <- getUcdpData("gedevents", "23.0.1")
ged.meta.df <- getUcdpMetaData(ged.df)
library(ucdp.api)
ged.meta.df <- getUcdpMetaData(ged.df)
if (as.text) {
return(txt)
} else {
message(txt)
}
#' @param ucdp.df A data.frame containing UCDP data with expected metadata columns.
#' @param as.text boolean: Should result be returned as text (TRUE) or printed
#' to the console (FALSE)? Default: FALSE
#'
#' @return A text summary of the metadata or message printed to console.
#' @export
#'
#' @examples
#' ucdp.df <- read.csv("your_ucdp_data_file.csv")
#' getUcdpMetaData(ucdp.df, as.text = TRUE)
getUcdpMetaData <- function(ucdp.df, as.text = FALSE) {
## Define dataset names and labels
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.lbls <- setNames(c("State-based conflict", "State based conflict, battle-related deaths",
"State based conflict, dyadic", "Non-state conflict",
"One-sided violence", "Georeferenced event"), dataset.names)
## Validate required columns and extract information
required.cols <- c("dataset", "version", "download_date")
if (!all(required.cols %in% names(ucdp.df))) {
warning("Metadata variables not found, outputting only known information.")
dataset <- version <- dataset.lbl <- "**unknown**"
download.date <- NA
} else {
dataset <- unique(ucdp.df$dataset)
dataset.lbl <- dataset.lbls[dataset]
version <- unique(ucdp.df$version)
download.date <- unique(ucdp.df$download.date)
}
## Process dates and coverage
if (dataset == "gedevents") {
ged.dates <- as.Date(unique(ucdp.df$date_start))
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
date.gaps <- all.dates[!all.dates %in% ged.dates]
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
} else {
years <- unique(ucdp.df$year)
start <- min(years)
end <- max(years)
}
## Format download date
download.date.formatted <- if(!is.na(download.date)){
format(download.date, '%d %B %Y')
} else {
"**unknown date**"
}
## Construct message text
txt <- glue::glue(
"UCDP {dataset.lbl} dataset, downloaded through the UCDP API on {download.date.formatted} using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api \n\n",
"Dataset version(s): {paste(version, collapse = ', ')} \n",
"Data coverage: {start} to {end} \n",
"For more information on the UCDP data and API, visit: https://ucdp.uu.se/apidocs/ \n",
if (dataset == "gedevents") {
date.gaps.msg <- if (!as.text && length(date.gaps) > 20) {
paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
} else {
paste(date.gaps, collapse = ", ")
}
sprintf("%s Date(s) missing from dataset:\n\n%s.", length(date.gaps), date.gaps.msg)
} else {
""
}
)
if (as.text) {
return(txt)
} else {
message(txt)
}
}
ged.meta.df <- getUcdpMetaData(ged.df)
#' getUcdpMetaData: Get metadata from UCDP Dataset downloaded through {ucdp.api}
#'
#' This function extracts metadata from a UCDP dataset downloaded through the
#' API using the {ucdp.api} R package and prints the results as a text string
#' or console message.
#'
#' @param ucdp.df A data.frame containing UCDP data with expected metadata columns.
#' @param as.text boolean: Should result be returned as text (TRUE) or printed
#' to the console (FALSE)? Default: FALSE
#'
#' @return A text summary of the metadata or message printed to console.
#' @export
#'
#' @examples
#' ucdp.df <- read.csv("your_ucdp_data_file.csv")
#' getUcdpMetaData(ucdp.df, as.text = TRUE)
getUcdpMetaData <- function(ucdp.df, as.text = FALSE) {
## Define dataset names and labels
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.lbls <- setNames(c("State-based conflict", "State based conflict, battle-related deaths",
"State based conflict, dyadic", "Non-state conflict",
"One-sided violence", "Georeferenced event"), dataset.names)
## Validate required columns and extract information
required.cols <- c("dataset", "version", "download_date")
if (!all(required.cols %in% names(ucdp.df))) {
warning("Metadata variables not found, outputting only known information.")
dataset <- version <- dataset.lbl <- "**unknown**"
download.date <- NA
} else {
dataset <- unique(ucdp.df$dataset)
dataset.lbl <- dataset.lbls[dataset]
version <- unique(ucdp.df$version)
download.date <- unique(ucdp.df$download_date)
}
## Process dates and coverage
if (dataset == "gedevents") {
ged.dates <- as.Date(unique(ucdp.df$date_start))
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
date.gaps <- all.dates[!all.dates %in% ged.dates]
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
} else {
years <- unique(ucdp.df$year)
start <- min(years)
end <- max(years)
}
## Format download date
download.date.formatted <- if(!is.na(download.date)){
format(download.date, '%d %B %Y')
} else {
"**unknown date**"
}
## Construct message text
txt <- glue::glue(
"UCDP {dataset.lbl} dataset, downloaded through the UCDP API on {download.date.formatted} using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api \n\n",
"Dataset version(s): {paste(version, collapse = ', ')} \n",
"Data coverage: {start} to {end} \n",
"For more information on the UCDP data and API, visit: https://ucdp.uu.se/apidocs/ \n",
if (dataset == "gedevents") {
date.gaps.msg <- if (!as.text && length(date.gaps) > 20) {
paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
} else {
paste(date.gaps, collapse = ", ")
}
sprintf("%s Date(s) missing from dataset:\n\n%s.", length(date.gaps), date.gaps.msg)
} else {
""
}
)
if (as.text) {
return(txt)
} else {
message(txt)
}
}
ged.meta.df <- getUcdpMetaData(ged.df)
devtools::document()
rm(list = c("getUcdpMetaData"))
devtools::document()
devtools::test()
devtools::build()
