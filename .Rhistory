## Get content of next page
response <- httr::GET(content.ls$NextPageUrl)
content.ls <- httr::content(response, encoding = "UTF-8")
## Append content from next page to content from previous n pages
outdata.ls <- c(outdata.ls, content.ls$Result)
}
## Output results as dataframe
outdata.df <- dplyr::bind_rows(lapply(outdata.ls, unlist))
## Convert true numeric character columns to numeric
## ... Function to identify numeric columns
isNumeric <- function(x){
all(suppressWarnings(!is.na(as.numeric(na.omit(x)))))
}
## ... Apply function to all columns (only converts true numeric columns)
outdata.df <- dplyr::mutate_if(outdata.df, isNumeric, as.numeric)
## Print output message
# data.lbl <- dataset.labels[dataset.names == dataset]
# candidate.data <- !grepl("[0-9]{2}\\.[0-9]{1}", version) & dataset == "gedevents"
#
# if(candidate.data){
#   data.lbl <- sprintf("%s (%s)", data.lbl, "(Candidate events)")
# }
#
# print(sprintf("Retrieved %s, Version %s.", data.lbl, version))
## Return output dataframe
return(outdata.df)
}
#' @param pagesize Page size of each individual query. Default: 100. Max: 1000
#' The UCDP API divides dataset into N pages of size S,
#' the query loops over all pages until full dataset is retrieved.
#'
#' @return data.frame with requested UCDP dataset
#' @export
#'
#' @examples
#' getUcdpData(dataset = ucdpprioconflict, version = "22.1", pagesize = 100)
#' getUcdpData(dataset = gedevents, version = "22.1", pagesize = 100)
getUcdpData <- function(©, version, pagesize = 100){
## Stop if requested pagesize greßater than 1000
if(pagesize > 1000){
stop("Page size cannot exceed 1000")
}
## Check if dataset name is valid
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.labels <- c("UCDP armed conflict dataset",
"UCDP battle-related deaths dataset",
"UCDP dyadic dataset",
"UCDP non-state conflict dataset",
"UCDP one-sided violence dataset",
"UCDP georeferenced event dataset")
dataset.string <- paste(paste0("'", dataset.names, "'"), collapse = ", ")
}
#' @param pagesize Page size of each individual query. Default: 100. Max: 1000
#' The UCDP API divides dataset into N pages of size S,
#' the query loops over all pages until full dataset is retrieved.
#'
#' @return data.frame with requested UCDP dataset
#' @export
#'
#' @examples
#' getUcdpData(dataset = ucdpprioconflict, version = "22.1", pagesize = 100)
#' getUcdpData(dataset = gedevents, version = "22.1", pagesize = 100)
getUcdpData <- function(version, pagesize = 100){
## Stop if requested pagesize greßater than 1000
if(pagesize > 1000){
stop("Page size cannot exceed 1000")
}
## Check if dataset name is valid
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.labels <- c("UCDP armed conflict dataset",
"UCDP battle-related deaths dataset",
"UCDP dyadic dataset",
"UCDP non-state conflict dataset",
"UCDP one-sided violence dataset",
"UCDP georeferenced event dataset")
dataset.string <- paste(paste0("'", dataset.names, "'"), collapse = ", ")
}
#' @param pagesize Page size of each individual query. Default: 100. Max: 1000
#' The UCDP API divides dataset into N pages of size S,
#' the query loops over all pages until full dataset is retrieved.
#'
#' @return data.frame with requested UCDP dataset
#' @export
#'
#' @examples
#' getUcdpData(dataset = ucdpprioconflict, version = "22.1", pagesize = 100)
#' getUcdpData(dataset = gedevents, version = "22.1", pagesize = 100)
getUcdpData <- function(version, pagesize = 100){
## Stop if requested pagesize greßater than 1000
if(pagesize > 1000){
stop("Page size cannot exceed 1000")
}
## Check if dataset name is valid
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.labels <- c("UCDP armed conflict dataset",
"UCDP battle-related deaths dataset",
"UCDP dyadic dataset",
"UCDP non-state conflict dataset",
"UCDP one-sided violence dataset",
"UCDP georeferenced event dataset")
dataset.string <- paste(paste0("'", dataset.names, "'"), collapse = ", ")
if(!dataset %in% dataset.names){
stop(sprintf("dataset name needs to be one of the following:\n%s",
dataset.string))
}
## Build initial URL: Insert dataset number, version and pagesize
url <- sprintf("https://ucdpapi.pcr.uu.se/api/%s/%s?pagesize=%s",
dataset, version, pagesize)
## Check if URL is valid
pingUrl(url)
## Get initial response and content
response <- httr::GET(url)
content.ls <- httr::content(response, encoding = "UTF-8")
outdata.ls <- content.ls$Result
## Get total number of pages needed to retrieve complete dataset
pages <- content.ls$TotalPages
## Get url of next page
nxt.url <- content.ls$NextPageUrl
## Loop over remaining pages and append results
## Stops if NextPageUrl does not exist (empty string)
while(content.ls$NextPageUrl != ""){
## Get content of next page
response <- httr::GET(content.ls$NextPageUrl)
content.ls <- httr::content(response, encoding = "UTF-8")
## Append content from next page to content from previous n pages
outdata.ls <- c(outdata.ls, content.ls$Result)
}
## Output results as dataframe
outdata.df <- dplyr::bind_rows(lapply(outdata.ls, unlist))
## Convert true numeric character columns to numeric
## ... Function to identify numeric columns
isNumeric <- function(x){
all(suppressWarnings(!is.na(as.numeric(na.omit(x)))))
}
## ... Apply function to all columns (only converts true numeric columns)
outdata.df <- dplyr::mutate_if(outdata.df, isNumeric, as.numeric)
## Print output message
# data.lbl <- dataset.labels[dataset.names == dataset]
# candidate.data <- !grepl("[0-9]{2}\\.[0-9]{1}", version) & dataset == "gedevents"
#
# if(candidate.data){
#   data.lbl <- sprintf("%s (%s)", data.lbl, "(Candidate events)")
# }
#
# print(sprintf("Retrieved %s, Version %s.", data.lbl, version))
## Return output dataframe
return(outdata.df)
}
#' @param pagesize Page size of each individual query. Default: 100. Max: 1000
#' The UCDP API divides dataset into N pages of size S,
#' the query loops over all pages until full dataset is retrieved.
#'
#' @return data.frame with requested UCDP dataset
#' @export
#'
#' @examples
#' getUcdpData(dataset = ucdpprioconflict, version = "22.1", pagesize = 100)
#' getUcdpData(dataset = gedevents, version = "22.1", pagesize = 100)
getUcdpData <- function(version, pagesize = 100){
## Stop if requested pagesize greßater than 1000
if(pagesize > 1000){
stop("Page size cannot exceed 1000")
}
## Check if dataset name is valid
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.labels <- c("UCDP armed conflict dataset",
"UCDP battle-related deaths dataset",
"UCDP dyadic dataset",
"UCDP non-state conflict dataset",
"UCDP one-sided violence dataset",
"UCDP georeferenced event dataset")
dataset.string <- paste(paste0("'", dataset.names, "'"), collapse = ", ")
if(!dataset %in% dataset.names){
stop(sprintf("dataset name needs to be one of the following:\n%s",
dataset.string))
}
## Build initial URL: Insert dataset number, version and pagesize
url <- sprintf("https://ucdpapi.pcr.uu.se/api/%s/%s?pagesize=%s",
dataset, version, pagesize)
## Check if URL is valid
pingUrl(url)
## Get initial response and content
response <- httr::GET(url)
content.ls <- httr::content(response, encoding = "UTF-8")
outdata.ls <- content.ls$Result
## Get total number of pages needed to retrieve complete dataset
pages <- content.ls$TotalPages
## Get url of next page
nxt.url <- content.ls$NextPageUrl
## Loop over remaining pages and append results
## Stops if NextPageUrl does not exist (empty string)
while(content.ls$NextPageUrl != ""){
## Get content of next page
response <- httr::GET(content.ls$NextPageUrl)
content.ls <- httr::content(response, encoding = "UTF-8")
## Append content from next page to content from previous n pages
outdata.ls <- c(outdata.ls, content.ls$Result)
}
## Output results as dataframe
outdata.df <- dplyr::bind_rows(lapply(outdata.ls, unlist))
## Convert true numeric character columns to numeric
## ... Function to identify numeric columns
isNumeric <- function(x){
all(suppressWarnings(!is.na(as.numeric(na.omit(x)))))
}
## ... Apply function to all columns (only converts true numeric columns)
outdata.df <- dplyr::mutate_if(outdata.df, isNumeric, as.numeric)
# Generate output message
data.lbl <- dataset.labels[dataset.names == dataset]
candidate.data <- !grepl("[0-9]{2}\\.[0-9]{1}", version) & dataset == "gedevents"
if(candidate.data){
data.lbl <- sprintf("%s (%s)", data.lbl, "(Candidate events)")
}
# Print output message
print(sprintf("Retrieved %s, Version %s.", data.lbl, version))
## Return output dataframe
return(outdata.df)
}
test <- getUcdpData("nonstate", version = "22.1", pagesize = 1000)
test <- getUcdpData(data = "nonstate", version = "22.1", pagesize = 1000)
test <- getUcdpData(dataset= "nonstate", version = "22.1", pagesize = 1000)
#' getUcdpData: Download data from the Uppsala Conflict Database Program API.
#'
#' @param dataset character. Name of UCDP dataset. Needs to be one of the following:
#' "ucdpprioconflict", "battledeaths", "dyadic", "nonstate", "onesided" (yearly data),
#' or "gedevents" (daily data, released in monthly batches)
#' The API does not require an account/key but there are some usage limitations
#' For more information, see: https://ucdp.uu.se/apidocs/
#'
#' @param version character. Dataset version number.
#' For yearly UCDP data: Format: YY.1 (e.g. 22.1 for data released in 2022)
#' For monthly UCDP GED data use format: YY.0.MM (e.g. 22.0.11 for data on November 2022)
#' For quarterly UCDP releases data use format: YY.01.YY.MM (e.g. 22.01.22.09 for data from Jan to Sep 2022)
#'
#' @param pagesize Page size of each individual query. Default: 100. Max: 1000
#' The UCDP API divides dataset into N pages of size S,
#' the query loops over all pages until full dataset is retrieved.
#'
#' @return data.frame with requested UCDP dataset
#' @export
#'
#' @examples
#' getUcdpData(dataset = ucdpprioconflict, version = "22.1", pagesize = 100)
#' getUcdpData(dataset = gedevents, version = "22.1", pagesize = 100)
getUcdpData <- function(dataset, version, pagesize = 100){
## Stop if requested pagesize greßater than 1000
if(pagesize > 1000){
stop("Page size cannot exceed 1000")
}
## Check if dataset name is valid
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.labels <- c("UCDP armed conflict dataset",
"UCDP battle-related deaths dataset",
"UCDP dyadic dataset",
"UCDP non-state conflict dataset",
"UCDP one-sided violence dataset",
"UCDP georeferenced event dataset")
dataset.string <- paste(paste0("'", dataset.names, "'"), collapse = ", ")
if(!dataset %in% dataset.names){
stop(sprintf("dataset name needs to be one of the following:\n%s",
dataset.string))
}
## Build initial URL: Insert dataset number, version and pagesize
url <- sprintf("https://ucdpapi.pcr.uu.se/api/%s/%s?pagesize=%s",
dataset, version, pagesize)
## Check if URL is valid
pingUrl(url)
## Get initial response and content
response <- httr::GET(url)
content.ls <- httr::content(response, encoding = "UTF-8")
outdata.ls <- content.ls$Result
## Get total number of pages needed to retrieve complete dataset
pages <- content.ls$TotalPages
## Get url of next page
nxt.url <- content.ls$NextPageUrl
## Loop over remaining pages and append results
## Stops if NextPageUrl does not exist (empty string)
while(content.ls$NextPageUrl != ""){
## Get content of next page
response <- httr::GET(content.ls$NextPageUrl)
content.ls <- httr::content(response, encoding = "UTF-8")
## Append content from next page to content from previous n pages
outdata.ls <- c(outdata.ls, content.ls$Result)
}
## Output results as dataframe
outdata.df <- dplyr::bind_rows(lapply(outdata.ls, unlist))
## Convert true numeric character columns to numeric
## ... Function to identify numeric columns
isNumeric <- function(x){
all(suppressWarnings(!is.na(as.numeric(na.omit(x)))))
}
## ... Apply function to all columns (only converts true numeric columns)
outdata.df <- dplyr::mutate_if(outdata.df, isNumeric, as.numeric)
# Generate output message
data.lbl <- dataset.labels[dataset.names == dataset]
candidate.data <- !grepl("[0-9]{2}\\.[0-9]{1}", version) & dataset == "gedevents"
if(candidate.data){
data.lbl <- sprintf("%s (%s)", data.lbl, "(Candidate events)")
}
# Print output message
print(sprintf("Retrieved %s, Version %s.", data.lbl, version))
## Return output dataframe
return(outdata.df)
}
test <- getUcdpData(dataset = "nonstate", version = "22.1", pagesize = 1000)
message
# Print output message
message(sprintf("Retrieved %s, Version %s.", data.lbl, version))
#' @param pagesize Page size of each individual query. Default: 100. Max: 1000
#' The UCDP API divides dataset into N pages of size S,
#' the query loops over all pages until full dataset is retrieved.
#'
#' @return data.frame with requested UCDP dataset
#' @export
#'
#' @examples
#' getUcdpData(dataset = ucdpprioconflict, version = "22.1", pagesize = 100)
#' getUcdpData(dataset = gedevents, version = "22.1", pagesize = 100)
getUcdpData <- function(dataset, version, pagesize = 100){
## Stop if requested pagesize greßater than 1000
if(pagesize > 1000){
stop("Page size cannot exceed 1000")
}
## Check if dataset name is valid
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.labels <- c("UCDP armed conflict dataset",
"UCDP battle-related deaths dataset",
"UCDP dyadic dataset",
"UCDP non-state conflict dataset",
"UCDP one-sided violence dataset",
"UCDP georeferenced event dataset")
dataset.string <- paste(paste0("'", dataset.names, "'"), collapse = ", ")
if(!dataset %in% dataset.names){
stop(sprintf("dataset name needs to be one of the following:\n%s",
dataset.string))
}
## Build initial URL: Insert dataset number, version and pagesize
url <- sprintf("https://ucdpapi.pcr.uu.se/api/%s/%s?pagesize=%s",
dataset, version, pagesize)
## Check if URL is valid
pingUrl(url)
## Get initial response and content
response <- httr::GET(url)
content.ls <- httr::content(response, encoding = "UTF-8")
outdata.ls <- content.ls$Result
## Get total number of pages needed to retrieve complete dataset
pages <- content.ls$TotalPages
## Get url of next page
nxt.url <- content.ls$NextPageUrl
## Loop over remaining pages and append results
## Stops if NextPageUrl does not exist (empty string)
while(content.ls$NextPageUrl != ""){
## Get content of next page
response <- httr::GET(content.ls$NextPageUrl)
content.ls <- httr::content(response, encoding = "UTF-8")
## Append content from next page to content from previous n pages
outdata.ls <- c(outdata.ls, content.ls$Result)
}
## Output results as dataframe
outdata.df <- dplyr::bind_rows(lapply(outdata.ls, unlist))
## Convert true numeric character columns to numeric
## ... Function to identify numeric columns
isNumeric <- function(x){
all(suppressWarnings(!is.na(as.numeric(na.omit(x)))))
}
## ... Apply function to all columns (only converts true numeric columns)
outdata.df <- dplyr::mutate_if(outdata.df, isNumeric, as.numeric)
# Generate output message
data.lbl <- dataset.labels[dataset.names == dataset]
candidate.data <- !grepl("[0-9]{2}\\.[0-9]{1}", version) & dataset == "gedevents"
if(candidate.data){
data.lbl <- sprintf("%s (%s)", data.lbl, "(Candidate events)")
}
# Print output message
message(sprintf("Retrieved %s, Version %s.", data.lbl, version))
## Return output dataframe
return(outdata.df)
}
test <- getUcdpData(dataset = "nonstate", version = "22.1", pagesize = 1000)
test <- getUcdpData(dataset = "gedevents", version = "22.01.22.09", pagesize = 1000)
version <- "22.01.22.09"
candidate.data <- !grepl("^[0-9]{2}\\.[0-9]{1}$", version) & dataset == "gedevents"
candidate.data
if(candidate.data){
data.lbl <- sprintf("%s (%s)", data.lbl, "(Candidate events)")
}
data.lbl
data.lbl <- sprintf("%s (%s)", data.lbl, "Candidate events")
if(candidate.data){
data.lbl <- sprintf("%s (%s)", data.lbl, "Candidate events")
}
data.lbl
# Generate output message
data.lbl <- dataset.labels[dataset.names == dataset]
candidate.data <- !grepl("^[0-9]{2}\\.[0-9]{1}$", version) & dataset == "gedevents"
if(candidate.data){
data.lbl <- sprintf("%s (%s)", data.lbl, "Candidate events")
}
data.lbl
#' @param pagesize Page size of each individual query. Default: 100. Max: 1000
#' The UCDP API divides dataset into N pages of size S,
#' the query loops over all pages until full dataset is retrieved.
#'
#' @return data.frame with requested UCDP dataset
#' @export
#'
#' @examples
#' getUcdpData(dataset = ucdpprioconflict, version = "22.1", pagesize = 100)
#' getUcdpData(dataset = gedevents, version = "22.1", pagesize = 100)
getUcdpData <- function(dataset, version, pagesize = 100){
## Stop if requested pagesize greßater than 1000
if(pagesize > 1000){
stop("Page size cannot exceed 1000")
}
## Check if dataset name is valid
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.labels <- c("UCDP armed conflict dataset",
"UCDP battle-related deaths dataset",
"UCDP dyadic dataset",
"UCDP non-state conflict dataset",
"UCDP one-sided violence dataset",
"UCDP georeferenced event dataset")
dataset.string <- paste(paste0("'", dataset.names, "'"), collapse = ", ")
if(!dataset %in% dataset.names){
stop(sprintf("dataset name needs to be one of the following:\n%s",
dataset.string))
}
## Build initial URL: Insert dataset number, version and pagesize
url <- sprintf("https://ucdpapi.pcr.uu.se/api/%s/%s?pagesize=%s",
dataset, version, pagesize)
## Check if URL is valid
pingUrl(url)
## Get initial response and content
response <- httr::GET(url)
content.ls <- httr::content(response, encoding = "UTF-8")
outdata.ls <- content.ls$Result
## Get total number of pages needed to retrieve complete dataset
pages <- content.ls$TotalPages
## Get url of next page
nxt.url <- content.ls$NextPageUrl
## Loop over remaining pages and append results
## Stops if NextPageUrl does not exist (empty string)
while(content.ls$NextPageUrl != ""){
## Get content of next page
response <- httr::GET(content.ls$NextPageUrl)
content.ls <- httr::content(response, encoding = "UTF-8")
## Append content from next page to content from previous n pages
outdata.ls <- c(outdata.ls, content.ls$Result)
}
## Output results as dataframe
outdata.df <- dplyr::bind_rows(lapply(outdata.ls, unlist))
## Convert true numeric character columns to numeric
## ... Function to identify numeric columns
isNumeric <- function(x){
all(suppressWarnings(!is.na(as.numeric(na.omit(x)))))
}
## ... Apply function to all columns (only converts true numeric columns)
outdata.df <- dplyr::mutate_if(outdata.df, isNumeric, as.numeric)
# Generate output message
data.lbl <- dataset.labels[dataset.names == dataset]
candidate.data <- !grepl("^[0-9]{2}\\.[0-9]{1}$", version) & dataset == "gedevents"
if(candidate.data){
data.lbl <- sprintf("%s (%s)", data.lbl, "Candidate events")
}
# Print output message
message(sprintf("Retrieved %s, Version %s.", data.lbl, version))
## Return output dataframe
return(outdata.df)
}
test <- getUcdpData(dataset = "gedevents", version = "22.01.22.09", pagesize = 1000)
dataset <- "gedevents"
version <- "22.1"
pagesize <- 1000
## Build initial URL: Insert dataset number, version and pagesize
url <- sprintf("https://ucdpapi.pcr.uu.se/api/%s/%s?pagesize=%s",
dataset, version, pagesize)
## Check if URL is valid
pingUrl(url)
## Get initial response and content
response <- httr::GET(url)
content.ls <- httr::content(response, encoding = "UTF-8")
outdata.ls <- content.ls$Result
outdata.ls
## Get total number of pages needed to retrieve complete dataset
pages <- content.ls$TotalPages
## Get url of next page
nxt.url <- content.ls$NextPageUrl
## Loop over remaining pages and append results
## Stops if NextPageUrl does not exist (empty string)
while(content.ls$NextPageUrl != ""){
## Get content of next page
response <- httr::GET(content.ls$NextPageUrl)
content.ls <- httr::content(response, encoding = "UTF-8")
## Append content from next page to content from previous n pages
outdata.ls <- c(outdata.ls, content.ls$Result)
}
## Loop over remaining pages and append results
## Stops if NextPageUrl does not exist (empty string)
system.time(while(content.ls$NextPageUrl != ""){
## Get content of next page
response <- httr::GET(content.ls$NextPageUrl)
content.ls <- httr::content(response, encoding = "UTF-8")
## Append content from next page to content from previous n pages
outdata.ls <- c(outdata.ls, content.ls$Result)
})
