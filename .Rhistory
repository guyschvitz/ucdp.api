pagesize = 200
if(!dataset %in% dataset.names) {
stop(sprintf("Invalid dataset name. Please choose one of the following datasets:\n%s.",
paste(sprintf("'%s'", dataset.names), collapse = ", ")))
}
## Build initial URL
url <- sprintf("https://ucdpapi.pcr.uu.se/api/%s/%s?pagesize=%s",
dataset, version, pagesize)
message(sprintf("Checking if dataset '%s' %s exists...", dataset, version))
## Attempt initial download with retries
attempt <- 1
while(attempt <= max.retries) {
tryCatch({
response <- httr::GET(url)
content.ls <- httr::content(response, encoding = "UTF-8")
break # Exit loop on success
}, error = function(e) {
if(attempt == max.retries) {
stop("Failed to retrieve data after ", attempt, " attempts.")
}
attempt <- attempt + 1
Sys.sleep(5) # Wait before retrying
})
}
max.retries <- 5
while(attempt <= max.retries) {
tryCatch({
response <- httr::GET(url)
content.ls <- httr::content(response, encoding = "UTF-8")
break # Exit loop on success
}, error = function(e) {
if(attempt == max.retries) {
stop("Failed to retrieve data after ", attempt, " attempts.")
}
attempt <- attempt + 1
Sys.sleep(5) # Wait before retrying
})
}
content.ls
is.list(content.ls)
stop(print(content.ls))
#'
#' @return data.frame with requested UCDP dataset
#' @export
#'
#' @importFrom httr GET content
#' @importFrom dplyr bind_rows mutate_if
#'
#' @examples
#' getUcdpData(dataset = ucdpprioconflict, version = "22.1", pagesize = 100)
#' getUcdpData(dataset = gedevents, version = "22.1", pagesize = 100)
getUcdpData <- function(dataset, version, pagesize = 100, max.retries = 10,
add.metadata = TRUE) {
if(pagesize > 1000) {
stop("Page size cannot exceed 1000")
}
## Validate dataset name
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
if(!dataset %in% dataset.names) {
stop(sprintf("Invalid dataset name. Please choose one of the following datasets:\n%s.",
paste(sprintf("'%s'", dataset.names), collapse = ", ")))
}
## Build initial URL
url <- sprintf("https://ucdpapi.pcr.uu.se/api/%s/%s?pagesize=%s",
dataset, version, pagesize)
message(sprintf("Checking if dataset '%s' %s exists...", dataset, version))
## Attempt initial download with retries
attempt <- 1
while(attempt <= max.retries) {
tryCatch({
response <- httr::GET(url)
content.ls <- httr::content(response, encoding = "UTF-8")
break # Exit loop on success
}, error = function(e) {
if(attempt == max.retries) {
stop("Failed to retrieve data after ", attempt, " attempts.")
}
attempt <- attempt + 1
Sys.sleep(5) # Wait before retrying
})
}
if(!is.list(content.ls)){
stop(print(content.ls))
}
## Initialize list and define number of pages with first page results
pages <- content.ls$TotalPages
outdata.ls <- list(content.ls$Result)
message(sprintf("\nGetting UCDP '%s' dataset, Version %s...", dataset, version))
## Initialize progress bar
pb <- txtProgressBar(min = 0, max = pages, style = 3)
## Loop over pages and handle retries
for(page in 2:pages) {
## ... Reset attempt counter for each page
attempt <- 1
while(attempt <= max.retries) {
tryCatch({
nxt.url <- sprintf("%s&page=%s", url, page)
## ... Send query and fetch results
response <- httr::GET(nxt.url)
content.ls <- httr::content(response, encoding = "UTF-8")
## ... Append results
outdata.ls[[page]] <- content.ls$Result
## ... Update progress bar
setTxtProgressBar(pb, page)
## ... Exit loop on success
break
}, error = function(e) {
if(attempt == max.retries) {
## ... Close progress bar on final attempt
close(pb)
stop("Failed to retrieve page ", page, " after ",
attempt, " attempts.")
}
attempt <- attempt + 1
## ... Wait before retrying
Sys.sleep(3)
})
}
}
close(pb)
## Process and return the data
outdata.df <- dplyr::bind_rows(lapply(outdata.ls, dplyr::bind_rows))
## Convert numeric columns
isNumeric <- function(x) {
all(suppressWarnings(!is.na(as.numeric(na.omit(x)))))
}
outdata.df <- dplyr::mutate_if(outdata.df, isNumeric, as.numeric)
## Add metadata if metadata == TRUE
if(add.metadata == TRUE){
outdata.df$dataset <- dataset
outdata.df$version <- version
outdata.df$download_date <- Sys.Date()
}
message("Done.")
return(outdata.df)
}
dataset
dataset
dataset <- unique(ucdp.df$dataset)
dataset.lbl <- dataset.lbls[dataset.names == dataset]
dataset.lbls <- c("State-based conflict", "State based conflict, battle-related deaths",
"State based conflict, dyadic", "Non-state conflict",
"One-sided violence", "Georeferenced event")
dataset <- unique(ucdp.df$dataset)
dataset.lbl <- dataset.lbls[dataset.names == dataset]
dataset.lbl
format(min(ged.dates), "%d %b %Y")
ucdp.df <- gedevents
ged.dates <- as.Date(unique(ucdp.df$date_start))
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
date.gaps <- all.dates[!all.dates %in% ged.dates]
start <- format(min(ged.dates), "%d %b %Y")
start
txt2 <- sprintf("Data coverage: %s to %s", start, end)
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
txt2 <- sprintf("Data coverage: %s to %s", start, end)
txt2
start <- min(years)
end <- max(years)
txt2 <- sprintf("Data coverage: %s to %s", start, end)
txt2
years <- unique(nsc$year)
start <- min(years)
end <- max(years)
txt2 <- sprintf("Data coverage: %s to %s", start, end)
txt2
ucdp.df$version <- "tre"
txt2 <- sprintf("Dataset version(s): %s", paste(unique(ucdp.df$version, collapse = ", ")))
txt2
txt1 <- sprintf("UCDP %s dataset, downloaded from the API on %s, using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api")
ucdp.df$download_date <- Sys.Date()
txt1 <- sprintf("UCDP %s dataset, downloaded from the API on %s, using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api",
format(ucdp.df$download_date, "%d %B %Y"))
txt1 <- sprintf("UCDP %s dataset, downloaded from the API on %s, using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api",
dataset.lbl, format(ucdp.df$download_date, "%d %B %Y"))
txt1
txt1 <- sprintf("UCDP %s dataset, downloaded from the API on %s, using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api",
dataset.lbl, format(unique(ucdp.df$download_date), "%d %B %Y"))
txt1
txt1 <- sprintf("UCDP %s dataset, downloaded through the UCDP API on %s, \nusing the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api",
dataset.lbl, format(unique(ucdp.df$download_date), "%d %B %Y"))
txt1
txt1 <- sprintf("UCDP %s dataset, downloaded through the UCDP API on %s,\nusing the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api",
dataset.lbl, format(unique(ucdp.df$download_date), "%d %B %Y"))
txt2 <- sprintf("Dataset version(s): %s", paste(unique(ucdp.df$version, collapse = ", ")))
txt3 <- sprintf("Data coverage: %s to %s", start, end)
date.gaps
ged.dates
ged.dates <- as.Date(unique(ucdp.df$date_start))
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
date.gaps <- all.dates[!all.dates %in% ged.dates]
all.dates %in% ged.dates
ged.dates
ged.dates <- as.Date(unique(ucdp.df$date_start))
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
getUcdpMetaData <- function(ucdp.df, download.date = Sys.Date(),
as.text = TRUE){
## Validate dataset name
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.lbls <- c("State-based conflict", "State based conflict, battle-related deaths",
"State based conflict, dyadic", "Non-state conflict",
"One-sided violence", "Georeferenced event")
dataset <- unique(ucdp.df$dataset)
dataset.lbl <- dataset.lbls[dataset.names == dataset]
version <- unique(ucdp.df$version)
years <- unique(ucdp.df$year)
if(dataset == "gedevents"){
ged.dates <- as.Date(unique(ucdp.df$date_start))
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
date.gaps <- all.dates[!all.dates %in% ged.dates]
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
} else {
start <- min(years)
end <- max(years)
}
txt1 <- sprintf("UCDP %s dataset, downloaded through the UCDP API on %s,\nusing the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api",
dataset.lbl, format(unique(ucdp.df$download_date), "%d %B %Y"))
txt2 <- sprintf("Dataset version(s): %s", paste(unique(ucdp.df$version, collapse = ", ")))
txt3 <- sprintf("Data coverage: %s to %s", start, end)
if(dataset == gedevents){
txt4 <- sprintf("Dates missing from dataset:\n\n%s.", paste(date.gaps, collapse = ", "))
txt3 <- paste(txt3, txt4)
}
}
sbc <- getUcdpData("ucdpprioconflict", version = "23.1")
#' getUcdpData: Download data from the Uppsala Conflict Database Program API.
#'
#' @param dataset character. Name of UCDP dataset. Needs to be one of the following:
#' "ucdpprioconflict", "battledeaths", "dyadic", "nonstate", "onesided" (yearly data),
#' or "gedevents" (daily data, released in monthly batches)
#' The API does not require an account/key but there are some usage limitations
#' For more information, see: https://ucdp.uu.se/apidocs/
#'
#' @param version character. Dataset version number.
#' For yearly UCDP data: Format: YY.1 (e.g. 22.1 for data released in 2022)
#' For monthly UCDP GED data use format: YY.0.MM (e.g. 22.0.11 for data on November 2022)
#' For quarterly UCDP releases data use format: YY.01.YY.MM (e.g. 22.01.22.09 for data from Jan to Sep 2022)
#'
#' @param pagesize numeric. Page size of each individual query. Default: 100. Max: 1000
#' The UCDP API divides dataset into N pages of size S,
#' the query loops over all pages until full dataset is retrieved.
#' @param max.retries numeric (integer). Maximum number of retry attempts for API
#' calls in case of failure, default: 10. Useful for managing temporary network or server issues.
#' Exceeding max.retries stops the function with an error.
#' @param add.metadata boolean: Add metadata to output dataset (TRUE) or not (FALSE).
#' Default: TRUE
#'
#' @return data.frame with requested UCDP dataset
#' @export
#'
#' @importFrom httr GET content
#' @importFrom dplyr bind_rows mutate_if
#'
#' @examples
#' getUcdpData(dataset = ucdpprioconflict, version = "22.1", pagesize = 100)
#' getUcdpData(dataset = gedevents, version = "22.1", pagesize = 100)
getUcdpData <- function(dataset, version, pagesize = 100, max.retries = 10,
add.metadata = TRUE) {
if(pagesize > 1000) {
stop("Page size cannot exceed 1000")
}
## Validate dataset name
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
if(!dataset %in% dataset.names) {
stop(sprintf("Invalid dataset name. Please choose one of the following datasets:\n%s.",
paste(sprintf("'%s'", dataset.names), collapse = ", ")))
}
## Build initial URL
url <- sprintf("https://ucdpapi.pcr.uu.se/api/%s/%s?pagesize=%s",
dataset, version, pagesize)
message(sprintf("Checking if dataset '%s' %s exists...", dataset, version))
## Attempt initial download with retries
attempt <- 1
while(attempt <= max.retries) {
tryCatch({
response <- httr::GET(url)
content.ls <- httr::content(response, encoding = "UTF-8")
break # Exit loop on success
}, error = function(e) {
if(attempt == max.retries) {
stop("Failed to retrieve data after ", attempt, " attempts.")
}
attempt <- attempt + 1
Sys.sleep(5) # Wait before retrying
})
}
if(!is.list(content.ls)){
stop(content.ls)
}
## Initialize list and define number of pages with first page results
pages <- content.ls$TotalPages
outdata.ls <- list(content.ls$Result)
message(sprintf("\nGetting UCDP '%s' dataset, Version %s...", dataset, version))
## Initialize progress bar
pb <- txtProgressBar(min = 0, max = pages, style = 3)
## Loop over pages and handle retries
for(page in 2:pages) {
## ... Reset attempt counter for each page
attempt <- 1
while(attempt <= max.retries) {
tryCatch({
nxt.url <- sprintf("%s&page=%s", url, page)
## ... Send query and fetch results
response <- httr::GET(nxt.url)
content.ls <- httr::content(response, encoding = "UTF-8")
## ... Append results
outdata.ls[[page]] <- content.ls$Result
## ... Update progress bar
setTxtProgressBar(pb, page)
## ... Exit loop on success
break
}, error = function(e) {
if(attempt == max.retries) {
## ... Close progress bar on final attempt
close(pb)
stop("Failed to retrieve page ", page, " after ",
attempt, " attempts.")
}
attempt <- attempt + 1
## ... Wait before retrying
Sys.sleep(3)
})
}
}
close(pb)
## Process and return the data
outdata.df <- dplyr::bind_rows(lapply(outdata.ls, dplyr::bind_rows))
## Convert numeric columns
isNumeric <- function(x) {
all(suppressWarnings(!is.na(as.numeric(na.omit(x)))))
}
outdata.df <- dplyr::mutate_if(outdata.df, isNumeric, as.numeric)
## Add metadata if metadata == TRUE
if(add.metadata == TRUE){
outdata.df$dataset <- dataset
outdata.df$version <- version
outdata.df$download_date <- Sys.Date()
}
message("Done.")
return(outdata.df)
}
sbc <- getUcdpData("ucdpprioconflict", version = "23.1")
ucdp.df
## Validate dataset name
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.lbls <- c("State-based conflict", "State based conflict, battle-related deaths",
"State based conflict, dyadic", "Non-state conflict",
"One-sided violence", "Georeferenced event")
dataset <- unique(ucdp.df$dataset)
dataset.lbl <- dataset.lbls[dataset.names == dataset]
version <- unique(ucdp.df$version)
years <- unique(ucdp.df$year)
if(dataset == "gedevents"){
ged.dates <- as.Date(unique(ucdp.df$date_start))
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
date.gaps <- all.dates[!all.dates %in% ged.dates]
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
} else {
start <- min(years)
end <- max(years)
}
txt1 <- sprintf("UCDP %s dataset, downloaded through the UCDP API on %s,\nusing the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api",
dataset.lbl, format(unique(ucdp.df$download_date), "%d %B %Y"))
txt2 <- sprintf("Dataset version(s): %s", paste(unique(ucdp.df$version, collapse = ", ")))
txt3 <- sprintf("Data coverage: %s to %s", start, end)
if(dataset == gedevents){
txt4 <- sprintf("Dates missing from dataset:\n\n%s.", paste(date.gaps, collapse = ", "))
txt3 <- paste(txt3, txt4)
}
dataset
dataset == gedevents
dataset <- unique(ucdp.df$dataset)
dataset
dataset.lbl <- dataset.lbls[dataset.names == dataset]
version <- unique(ucdp.df$version)
years <- unique(ucdp.df$year)
if(dataset == "gedevents"){
ged.dates <- as.Date(unique(ucdp.df$date_start))
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
date.gaps <- all.dates[!all.dates %in% ged.dates]
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
} else {
start <- min(years)
end <- max(years)
}
unique(ucdp.df$download_date)
txt1 <- sprintf("UCDP %s dataset, downloaded through the UCDP API on %s,\nusing the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api",
dataset.lbl, format(unique(ucdp.df$download_date), "%d %B %Y"))
txt1
txt2 <- sprintf("Dataset version(s): %s", paste(unique(ucdp.df$version, collapse = ", ")))
txt3 <- sprintf("Data coverage: %s to %s", start, end)
dataset == gedevents
dataset == "gedevents"
txt4 <- sprintf("Dates missing from dataset:\n\n%s.", paste(date.gaps, collapse = ", "))
txt4
txt1 <- sprintf("UCDP %s dataset, downloaded through the UCDP API on %s,\nusing the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api",
dataset.lbl, format(unique(ucdp.df$download_date), "%d %B %Y"))
txt2 <- sprintf("Dataset version(s): %s", paste(unique(ucdp.df$version, collapse = ", ")))
txt3 <- sprintf("Data coverage: %s to %s", start, end)
txt4 <- "For more information on the UCDP datasets and API, visit: https://ucdp.uu.se/apidocs/"
if(dataset == "gedevents"){
txt5 <- sprintf("Dates missing from dataset:\n\n%s.", paste(date.gaps, collapse = ", "))
txt4 <- paste(txt4, txt5, collapse = "\n")
}
msg.txt <- paste(txt1, txt2, txt3, txt4, collapse = "\n")
msg.txt
message(msg.txt)
date.gaps
if_else(length(date.gaps) > 20, c(date.gaps[1:20], "..."),
date.gaps)
date.gaps.vec <- if(length(date.gaps) > 20){
c(date.gaps[1:20], "...")
} else {
date.gaps
}
length(date.gaps)
date.gaps
paste(date.gaps[1:20], "...")
paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
if(length(date.gaps) > 20){
date.gaps.vec <- paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
} else {
date.gaps.vec <- paste(date.gaps, collapse = ", ")
}
txt5 <- sprintf("%s Dates missing from dataset:\n\n%s.",
length(date.gaps),
date.gaps.vec)
txt5
msg.txt <- paste(txt1, txt2, txt3, txt4, collapse = "\n")
message(msg.txt)
txt5
txt5 <- sprintf("%s Dates missing from dataset:\n\n%s.",
length(date.gaps),
date.gaps.vec)
txt4 <- paste(txt4, txt5, collapse = "\n")
msg.txt <- paste(txt1, txt2, txt3, txt4, collapse = "\n")
message(msg.txt)
length(date.gaps)
txt5 <- sprintf("%s Dates missing from dataset:\n\n%s.",
length(date.gaps),
date.gaps.vec)
txt4 <- "For more information on the UCDP datasets and API, visit: https://ucdp.uu.se/apidocs/"
txt5 <- sprintf("%s Dates missing from dataset:\n\n%s.",
length(date.gaps),
date.gaps.vec)
txt4 <- paste(txt4, txt5, collapse = "\n")
msg.txt <- paste(txt1, txt2, txt3, txt4, collapse = "\n")
message(msg.txt)
msg.txt
txt1 <- sprintf("UCDP %s dataset, downloaded through the UCDP API on %s,\nusing the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api \n",
dataset.lbl, format(unique(ucdp.df$download_date), "%d %B %Y"))
txt2 <- sprintf("Dataset version(s): %s \n", paste(unique(ucdp.df$version, collapse = ", ")))
txt3 <- sprintf("Data coverage: %s to %s \n", start, end)
txt4 <- "For more information on the UCDP datasets and API, visit: https://ucdp.uu.se/apidocs/ \n"
if(dataset == "gedevents"){
if(length(date.gaps) > 20){
date.gaps.vec <- paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
} else {
date.gaps.vec <- paste(date.gaps, collapse = ", ")
}
txt5 <- sprintf("%s Dates missing from dataset:\n\n%s.",
length(date.gaps),
date.gaps.vec)
txt4 <- paste(txt4, txt5, collapse = "\n")
}
msg.txt <- paste(txt1, txt2, txt3, txt4, collapse = "\n")
message(msg.txt)
txt1 <- sprintf("UCDP %s dataset, downloaded through the UCDP API on %s using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api \n",
dataset.lbl, format(unique(ucdp.df$download_date), "%d %B %Y"))
txt2 <- sprintf("Dataset version(s): %s \n", paste(unique(ucdp.df$version, collapse = ", ")))
txt3 <- sprintf("Data coverage: %s to %s \n", start, end)
txt4 <- "For more information on the UCDP datasets and API, visit: https://ucdp.uu.se/apidocs/ \n"
if(dataset == "gedevents"){
if(length(date.gaps) > 20){
date.gaps.vec <- paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
} else {
date.gaps.vec <- paste(date.gaps, collapse = ", ")
}
txt5 <- sprintf("%s Dates missing from dataset:\n\n%s.",
length(date.gaps),
date.gaps.vec)
txt4 <- paste(txt4, txt5, collapse = "\n")
}
msg.txt <- paste(txt1, txt2, txt3, txt4, collapse = "\n")
message(msg.txt)
txt1 <- sprintf("UCDP %s dataset, downloaded through the UCDP API on %s using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api \n\n",
dataset.lbl, format(unique(ucdp.df$download_date), "%d %B %Y"))
txt2 <- sprintf("Dataset version(s): %s \n", paste(unique(ucdp.df$version, collapse = ", ")))
txt3 <- sprintf("Data coverage: %s to %s \n", start, end)
txt4 <- "For more information on the UCDP datasets and API, visit: https://ucdp.uu.se/apidocs/ \n"
if(dataset == "gedevents"){
if(length(date.gaps) > 20){
date.gaps.vec <- paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
} else {
date.gaps.vec <- paste(date.gaps, collapse = ", ")
}
txt5 <- sprintf("%s Dates missing from dataset:\n\n%s.",
length(date.gaps),
date.gaps.vec)
txt4 <- paste(txt4, txt5, collapse = "\n")
}
msg.txt <- paste(txt1, txt2, txt3, txt4, collapse = "\n")
message(msg.txt)
ged.df <- targets::tar_read(ged.df)
