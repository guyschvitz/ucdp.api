ged.dates <- as.Date(unique(ucdp.df$date_start))
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
date.gaps <- all.dates[!all.dates %in% ged.dates]
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
} else {
start <- min(years)
end <- max(years)
}
txt1 <- sprintf("UCDP %s dataset, downloaded through the UCDP API on %s using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api \n\n",
dataset.lbl, format(unique(ucdp.df$download_date), "%d %B %Y"))
txt2 <- sprintf("Dataset version(s): %s \n", paste(unique(ucdp.df$version, collapse = ", ")))
txt3 <- sprintf("Data coverage: %s to %s \n", start, end)
txt4 <- "For more information on the UCDP data and API, visit: https://ucdp.uu.se/apidocs/ \n"
txt5 <- NULL
if(dataset == "gedevents"){
if(as.text == FALSE && length(date.gaps) > 20){
date.gaps.vec <- paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
} else {
date.gaps.vec <- paste(date.gaps, collapse = ", ")
}
txt5 <- sprintf("%s Date(s) missing from dataset:\n\n%s.",
length(date.gaps),
date.gaps.vec)
}
msg.txt <- paste(txt1, txt2, txt3, txt4, txt5, collapse = "\n")
if(as.text == FALSE){
message(msg.txt)
} else {
return(msg.txt)
}
}
getUcdpMetaData(sbc)
getUcdpMetaData(sbc, as.text == FALSE)
getUcdpMetaData(sbc, as.text == TRUE)
getUcdpMetaData(nsc, as.text == TRUE)
getUcdpMetaData <- function(ucdp.df, as.text = TRUE){
## Validate dataset name
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.lbls <- c("State-based conflict", "State based conflict, battle-related deaths",
"State based conflict, dyadic", "Non-state conflict",
"One-sided violence", "Georeferenced event")
if(c("dataset", "version", "download_date") %in% names(ucdp.df)){
dataset <- unique(ucdp.df$dataset)
dataset.lbl <- dataset.lbls[dataset.names == dataset]
version <- unique(ucdp.df$version)
download_date <- unique(ucdp.df$download_date)
} else {
warning("Metadata variables not found, outputting only known information.")
dataset <- "unknown"
dataset.lbl <- "unknown dataset"
download_date <- "unknown date"
}
years <- unique(ucdp.df$year)
if(dataset == "gedevents" | "date_start" %in% names(ucdp.df)){
dataset <- "gedevents"
dataset.lbl <- dataset.lbls[dataset.names == dataset]
ged.dates <- as.Date(unique(ucdp.df$date_start))
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
date.gaps <- all.dates[!all.dates %in% ged.dates]
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
} else {
start <- min(years)
end <- max(years)
}
txt1 <- sprintf("UCDP %s dataset, downloaded through the UCDP API on %s using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api \n\n",
dataset.lbl, format(unique(ucdp.df$download_date), "%d %B %Y"))
txt2 <- sprintf("Dataset version(s): %s \n", paste(unique(ucdp.df$version, collapse = ", ")))
txt3 <- sprintf("Data coverage: %s to %s \n", start, end)
txt4 <- "For more information on the UCDP data and API, visit: https://ucdp.uu.se/apidocs/ \n"
txt5 <- NULL
if(dataset == "gedevents"){
if(as.text == FALSE && length(date.gaps) > 20){
date.gaps.vec <- paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
} else {
date.gaps.vec <- paste(date.gaps, collapse = ", ")
}
txt5 <- sprintf("%s Date(s) missing from dataset:\n\n%s.",
length(date.gaps),
date.gaps.vec)
}
msg.txt <- paste(txt1, txt2, txt3, txt4, txt5, collapse = "\n")
if(as.text == FALSE){
message(msg.txt)
} else {
return(msg.txt)
}
}
getUcdpMetaData(nsc, as.text == TRUE)
getUcdpMetaData <- function(ucdp.df, as.text = TRUE){
## Validate dataset name
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.lbls <- c("State-based conflict", "State based conflict, battle-related deaths",
"State based conflict, dyadic", "Non-state conflict",
"One-sided violence", "Georeferenced event")
if(all(c("dataset", "version", "download_date") %in% names(ucdp.df))){
dataset <- unique(ucdp.df$dataset)
dataset.lbl <- dataset.lbls[dataset.names == dataset]
version <- unique(ucdp.df$version)
download_date <- unique(ucdp.df$download_date)
} else {
warning("Metadata variables not found, outputting only known information.")
dataset <- "unknown"
dataset.lbl <- "unknown dataset"
download_date <- "unknown date"
}
years <- unique(ucdp.df$year)
if(dataset == "gedevents" | "date_start" %in% names(ucdp.df)){
dataset <- "gedevents"
dataset.lbl <- dataset.lbls[dataset.names == dataset]
ged.dates <- as.Date(unique(ucdp.df$date_start))
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
date.gaps <- all.dates[!all.dates %in% ged.dates]
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
} else {
start <- min(years)
end <- max(years)
}
txt1 <- sprintf("UCDP %s dataset, downloaded through the UCDP API on %s using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api \n\n",
dataset.lbl, format(unique(ucdp.df$download_date), "%d %B %Y"))
txt2 <- sprintf("Dataset version(s): %s \n", paste(unique(ucdp.df$version, collapse = ", ")))
txt3 <- sprintf("Data coverage: %s to %s \n", start, end)
txt4 <- "For more information on the UCDP data and API, visit: https://ucdp.uu.se/apidocs/ \n"
txt5 <- NULL
if(dataset == "gedevents"){
if(as.text == FALSE && length(date.gaps) > 20){
date.gaps.vec <- paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
} else {
date.gaps.vec <- paste(date.gaps, collapse = ", ")
}
txt5 <- sprintf("%s Date(s) missing from dataset:\n\n%s.",
length(date.gaps),
date.gaps.vec)
}
msg.txt <- paste(txt1, txt2, txt3, txt4, txt5, collapse = "\n")
if(as.text == FALSE){
message(msg.txt)
} else {
return(msg.txt)
}
}
getUcdpMetaData(nsc, as.text == TRUE)
getUcdpMetaData(ged.df, as.text == TRUE)
getUcdpMetaData(ged.df, as.text == FALSE)
#' This function extracts and presents metadata from a UCDP dataset dataframe.
#' It checks for essential metadata columns and provides a summary including
#' dataset labels, versions, download dates, and coverage.
#'
#' @param ucdp.df A dataframe containing UCDP data with expected metadata columns.
#' @param as.text Logical indicating if the result should be returned as text instead of printed.
#' @return A text summary of the metadata or prints the summary directly.
#' @examples
#' ucdp.df <- read.csv("your_ucdp_data_file.csv")
#' getUcdpMetaData(ucdp.df, as.text = TRUE)
getUcdpMetaData <- function(ucdp.df, as.text = FALSE) {
# Define dataset names and labels
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.lbls <- setNames(c("State-based conflict", "State based conflict, battle-related deaths",
"State based conflict, dyadic", "Non-state conflict",
"One-sided violence", "Georeferenced event"), dataset.names)
# Validate required columns
required.cols <- c("dataset", "version", "download_date")
if (!all(required.cols %in% names(ucdp.df))) {
warning("Metadata variables not found, outputting only known information.")
dataset <- version <- download_date <- "**unknown**"
} else {
dataset <- unique(ucdp.df$dataset)
dataset.lbl <- dataset.lbls[dataset]
version <- unique(ucdp.df$version)
download_date <- unique(ucdp.df$download_date)
}
# Handle dates and coverage
if ("date_start" %in% names(ucdp.df) && dataset == "gedevents") {
ged.dates <- as.Date(unique(ucdp.df$date_start))
date.gaps <- setdiff(seq(min(ged.dates), max(ged.dates), "1 day"), ged.dates)
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
} else {
years <- unique(ucdp.df$year)
start <- min(years)
end <- max(years)
}
# Construct message text
txt <- glue::glue(
"UCDP {dataset.lbl} dataset, downloaded through the UCDP API on {format(download_date, '%d %B %Y')} using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api \n\n",
"Dataset version(s): {paste(version, collapse = ', ')} \n",
"Data coverage: {start} to {end} \n",
"For more information on the UCDP data and API, visit: https://ucdp.uu.se/apidocs/ \n",
if (dataset == "gedevents") {
date.gaps.msg <- if (!as.text && length(date.gaps) > 20) {
paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
} else {
paste(date.gaps, collapse = ", ")
}
sprintf("%s Date(s) missing from dataset:\n\n%s.", length(date.gaps), date.gaps.msg)
} else {
""
}
)
if (as.text) {
return(txt)
} else {
message(txt)
}
}
getUcdpMetaData(sbc, as.text == FALSE)
getUcdpMetaData(sbc, as.text == TRUE)
txt<- getUcdpMetaData(sbc, as.text == TRUE)
txt
getUcdpMetaData(nsc, as.text == TRUE)
names(nsc)
#' This function extracts and presents metadata from a UCDP dataset dataframe.
#' It checks for essential metadata columns and provides a summary including
#' dataset labels, versions, download dates, and coverage.
#'
#' @param ucdp.df A dataframe containing UCDP data with expected metadata columns.
#' @param as.text Logical indicating if the result should be returned as text instead of printed.
#' @return A text summary of the metadata or prints the summary directly.
#' @examples
#' ucdp.df <- read.csv("your_ucdp_data_file.csv")
#' getUcdpMetaData(ucdp.df, as.text = TRUE)
getUcdpMetaData <- function(ucdp.df, as.text = FALSE) {
# Define dataset names and labels
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.lbls <- setNames(c("State-based conflict", "State based conflict, battle-related deaths",
"State based conflict, dyadic", "Non-state conflict",
"One-sided violence", "Georeferenced event"), dataset.names)
# Validate required columns
required.cols <- c("dataset", "version", "download_date")
if (!all(required.cols %in% names(ucdp.df))) {
warning("Metadata variables not found, outputting only known information.")
dataset <- version <- download_date <- "**unknown**"
} else {
dataset <- unique(ucdp.df$dataset)
dataset.lbl <- dataset.lbls[dataset]
version <- unique(ucdp.df$version)
download_date <- unique(ucdp.df$download_date)
}
# Handle dates and coverage
if (dataset == "gedevents") {
ged.dates <- as.Date(unique(ucdp.df$date_start))
date.gaps <- setdiff(seq(min(ged.dates), max(ged.dates), "1 day"), ged.dates)
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
} else {
years <- unique(ucdp.df$year)
start <- min(years)
end <- max(years)
}
# Construct message text
txt <- glue::glue(
"UCDP {dataset.lbl} dataset, downloaded through the UCDP API on {format(download_date, '%d %B %Y')} using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api \n\n",
"Dataset version(s): {paste(version, collapse = ', ')} \n",
"Data coverage: {start} to {end} \n",
"For more information on the UCDP data and API, visit: https://ucdp.uu.se/apidocs/ \n",
if (dataset == "gedevents") {
date.gaps.msg <- if (!as.text && length(date.gaps) > 20) {
paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
} else {
paste(date.gaps, collapse = ", ")
}
sprintf("%s Date(s) missing from dataset:\n\n%s.", length(date.gaps), date.gaps.msg)
} else {
""
}
)
if (as.text) {
return(txt)
} else {
message(txt)
}
}
getUcdpMetaData(ged.df, as.text == FALSE)
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
date.gaps <- all.dates[!all.dates %in% ged.dates]
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
#' This function extracts and presents metadata from a UCDP dataset dataframe.
#' It checks for essential metadata columns and provides a summary including
#' dataset labels, versions, download dates, and coverage.
#'
#' @param ucdp.df A dataframe containing UCDP data with expected metadata columns.
#' @param as.text Logical indicating if the result should be returned as text instead of printed.
#' @return A text summary of the metadata or prints the summary directly.
#' @examples
#' ucdp.df <- read.csv("your_ucdp_data_file.csv")
#' getUcdpMetaData(ucdp.df, as.text = TRUE)
getUcdpMetaData <- function(ucdp.df, as.text = FALSE) {
# Define dataset names and labels
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.lbls <- setNames(c("State-based conflict", "State based conflict, battle-related deaths",
"State based conflict, dyadic", "Non-state conflict",
"One-sided violence", "Georeferenced event"), dataset.names)
# Validate required columns
required.cols <- c("dataset", "version", "download_date")
if (!all(required.cols %in% names(ucdp.df))) {
warning("Metadata variables not found, outputting only known information.")
dataset <- version <- download_date <- "**unknown**"
} else {
dataset <- unique(ucdp.df$dataset)
dataset.lbl <- dataset.lbls[dataset]
version <- unique(ucdp.df$version)
download_date <- unique(ucdp.df$download_date)
}
# Handle dates and coverage
if (dataset == "gedevents") {
ged.dates <- as.Date(unique(ucdp.df$date_start))
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
date.gaps <- all.dates[!all.dates %in% ged.dates]
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
} else {
years <- unique(ucdp.df$year)
start <- min(years)
end <- max(years)
}
# Construct message text
txt <- glue::glue(
"UCDP {dataset.lbl} dataset, downloaded through the UCDP API on {format(download_date, '%d %B %Y')} using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api \n\n",
"Dataset version(s): {paste(version, collapse = ', ')} \n",
"Data coverage: {start} to {end} \n",
"For more information on the UCDP data and API, visit: https://ucdp.uu.se/apidocs/ \n",
if (dataset == "gedevents") {
date.gaps.msg <- if (!as.text && length(date.gaps) > 20) {
paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
} else {
paste(date.gaps, collapse = ", ")
}
sprintf("%s Date(s) missing from dataset:\n\n%s.", length(date.gaps), date.gaps.msg)
} else {
""
}
)
if (as.text) {
return(txt)
} else {
message(txt)
}
}
getUcdpMetaData(ged.df, as.text == FALSE)
getUcdpMetaData(nsc, as.text == TRUE)
#' This function extracts and presents metadata from a UCDP dataset dataframe.
#' It checks for essential metadata columns and provides a summary including
#' dataset labels, versions, download dates, and coverage.
#'
#' @param ucdp.df A dataframe containing UCDP data with expected metadata columns.
#' @param as.text Logical indicating if the result should be returned as text instead of printed.
#' @return A text summary of the metadata or prints the summary directly.
#' @examples
#' ucdp.df <- read.csv("your_ucdp_data_file.csv")
#' getUcdpMetaData(ucdp.df, as.text = TRUE)
getUcdpMetaData <- function(ucdp.df, as.text = FALSE) {
# Define dataset names and labels
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.lbls <- setNames(c("State-based conflict", "State based conflict, battle-related deaths",
"State based conflict, dyadic", "Non-state conflict",
"One-sided violence", "Georeferenced event"), dataset.names)
# Validate required columns
required.cols <- c("dataset", "version", "download_date")
if (!all(required.cols %in% names(ucdp.df))) {
warning("Metadata variables not found, outputting only known information.")
dataset <- version <- "**unknown**"
download_date <- NA
} else {
dataset <- unique(ucdp.df$dataset)
dataset.lbl <- dataset.lbls[dataset]
version <- unique(ucdp.df$version)
download_date <- unique(ucdp.df$download_date)
}
# Handle dates and coverage
if (dataset == "gedevents") {
ged.dates <- as.Date(unique(ucdp.df$date_start))
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
date.gaps <- all.dates[!all.dates %in% ged.dates]
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
} else {
years <- unique(ucdp.df$year)
start <- min(years)
end <- max(years)
}
# Construct message text
txt <- glue::glue(
"UCDP {dataset.lbl} dataset, downloaded through the UCDP API on {format(download_date, '%d %B %Y')} using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api \n\n",
"Dataset version(s): {paste(version, collapse = ', ')} \n",
"Data coverage: {start} to {end} \n",
"For more information on the UCDP data and API, visit: https://ucdp.uu.se/apidocs/ \n",
if (dataset == "gedevents") {
date.gaps.msg <- if (!as.text && length(date.gaps) > 20) {
paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
} else {
paste(date.gaps, collapse = ", ")
}
sprintf("%s Date(s) missing from dataset:\n\n%s.", length(date.gaps), date.gaps.msg)
} else {
""
}
)
if (as.text) {
return(txt)
} else {
message(txt)
}
}
getUcdpMetaData(nsc, as.text == TRUE)
#' This function extracts and presents metadata from a UCDP dataset dataframe.
#' It checks for essential metadata columns and provides a summary including
#' dataset labels, versions, download dates, and coverage.
#'
#' @param ucdp.df A dataframe containing UCDP data with expected metadata columns.
#' @param as.text Logical indicating if the result should be returned as text instead of printed.
#' @return A text summary of the metadata or prints the summary directly.
#' @examples
#' ucdp.df <- read.csv("your_ucdp_data_file.csv")
#' getUcdpMetaData(ucdp.df, as.text = TRUE)
getUcdpMetaData <- function(ucdp.df, as.text = FALSE) {
## Define dataset names and labels
dataset.names <- c("ucdpprioconflict", "battledeaths", "dyadic", "nonstate",
"onesided", "gedevents")
dataset.lbls <- setNames(c("State-based conflict", "State based conflict, battle-related deaths",
"State based conflict, dyadic", "Non-state conflict",
"One-sided violence", "Georeferenced event"), dataset.names)
## Validate required columns and extract information
required.cols <- c("dataset", "version", "download_date")
if (!all(required.cols %in% names(ucdp.df))) {
warning("Metadata variables not found, outputting only known information.")
dataset <- version <- "**unknown**"
download.date <- NA
} else {
dataset <- unique(ucdp.df$dataset)
dataset.lbl <- dataset.lbls[dataset]
version <- unique(ucdp.df$version)
download.date <- unique(ucdp.df$download_date)
}
## Process dates and coverage
if (dataset == "gedevents") {
ged.dates <- as.Date(unique(ucdp.df$date_start))
all.dates <- seq(min(ged.dates), max(ged.dates), "1 day")
date.gaps <- all.dates[!all.dates %in% ged.dates]
start <- format(min(ged.dates), "%d %b %Y")
end <- format(max(ged.dates), "%d %b %Y")
} else {
years <- unique(ucdp.df$year)
start <- min(years)
end <- max(years)
}
## Format download date
download.date.formatted <- if(!is.na(download.date)){
format(download_date, '%d %B %Y')
} else {
"**unknown date**"
}
## Construct message text
txt <- glue::glue(
"UCDP {dataset.lbl} dataset, downloaded through the UCDP API on {download.date.formatted} using the ucdp.api R package:\nhttps://github.com/guyschvitz/ucdp.api \n\n",
"Dataset version(s): {paste(version, collapse = ', ')} \n",
"Data coverage: {start} to {end} \n",
"For more information on the UCDP data and API, visit: https://ucdp.uu.se/apidocs/ \n",
if (dataset == "gedevents") {
date.gaps.msg <- if (!as.text && length(date.gaps) > 20) {
paste(c(as.character(date.gaps[1:20]), "..."), collapse = ", ")
} else {
paste(date.gaps, collapse = ", ")
}
sprintf("%s Date(s) missing from dataset:\n\n%s.", length(date.gaps), date.gaps.msg)
} else {
""
}
)
if (as.text) {
return(txt)
} else {
message(txt)
}
}
nsc <- getUcdpData("nonstate", version = "23.1", add.metadata = FALSE)
getUcdpMetaData(nsc, as.text == TRUE)
getUcdpMetaData(nsc, as.text == FALSE)
devtools::document()
rm(list = c("gedUcdpData"))
rm(list = c("getUcdpData"))
devtools::document()
rm(list = c("getUcdpMetaData"))
devtools::document()
devtools::build()
sbc.df <- getUcdpData(dataset = "ucdpprioconflict", "23.1", add.metadata = TRUE)
getUcdpMetadata(sbc.df, as.text = FALSE)
## Extract metadata
getUcdpMetaData(sbc.df, as.text = FALSE)
osv.df <- getUcdpData(dataset = "onesided", version = "23.1", pagesize = 1000)
gedc.df <- getUcdpData(dataset = "gedevents", version = "23.0.11", pagesize = 1000, add.metadata = FALSE)
devtools::document()
devtools::document()
devtools::build()
devtools::document()
devtools::document()
devtools::document()
devtools::build()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::build()
devtools::test()
